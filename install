#!/usr/bin/env python3
import argparse
import os
import sys

from pathlib import Path
from typing import List, NamedTuple

DEFAULT_COMMAND = "validate"
# TODO: Do we want to possibly install elsewhere?
HOME = Path.home()
non_installable = [".git", ".gitignore", "install"]


class InstallSpecial(NamedTuple):
    path: Path
    platforms: List[str]


exceptions = {
    "Microsoft.PowerShell_profile.ps1": InstallSpecial(
        path=Path.home()
        / "Documents/WindowsPowerShell/Microsoft.PowerShell_profile.ps1",
        platforms=["win32"],
    ),
}
non_installable += exceptions.keys()


def info(*args, **kwargs):
    print("[*]", *args, **kwargs)


def error(*args, **kwargs):
    print("[E]", *args, **kwargs)


if sys.platform == "win32":
    __CSL = None

    def symlink(source, link_name):
        """symlink(source, link_name)
        Creates a symbolic link pointing to source named link_name"""
        global __CSL
        if __CSL is None:
            import ctypes

            csl = ctypes.windll.kernel32.CreateSymbolicLinkW
            csl.argtypes = (ctypes.c_wchar_p, ctypes.c_wchar_p, ctypes.c_uint32)
            csl.restype = ctypes.c_ubyte
            __CSL = csl
        flags = 0
        if source is not None and os.path.isdir(source):
            flags = 1
        if __CSL(str(link_name), str(source), flags) == 0:
            raise ctypes.WinError()


else:

    def symlink(source, link_name):
        return os.symlink(source, link_name)


def validate_link(lnk, dst, config):
    if not lnk.exists():
        error("symlink to {} is not installed at {}".format(dst, lnk))
        return True
    if not lnk.is_symlink():
        error("{} exists but is not a symlink".format(lnk))
        return True

    link = lnk.readlink().resolve()
    if link != dst:
        error(
            "{} exists but is not a symlink to {}, it points to {}".format(
                lnk, dst, link
            )
        )
        return True

    if config.verbose:
        info("OK: {} -> {}".format(lnk, dst))
    return False


def validate(d, config):
    had_error = False
    for f in os.listdir(d):
        if f in non_installable:
            # only mention if it's an exception
            if config.verbose and f not in exceptions:
                print("Non-installable file: {}".format(f))
            continue

        abs_f = (Path(d) / f).resolve()
        HOME_f = Path(HOME) / f
        had_error |= validate_link(HOME_f, abs_f, config)

    for dst, special in exceptions.items():
        if sys.platform not in special.platforms:
            if config.verbose:
                print(
                    "Non-installable file: {} (sys.platform: {}, platforms: {})".format(
                        dst, sys.platform, special.platforms
                    )
                )
            continue

        lnk = special.path.expanduser()
        dst = Path(dst)
        if not dst.is_absolute():
            dst = Path.cwd() / dst
        dst.resolve()

        had_error |= validate_link(lnk, dst, config)

    if not had_error:
        info("All seems to be ok!")
    else:
        error("whoops!")


def symlink_is_ok(lnk, dst):
    return lnk.exists() and lnk.is_symlink() and lnk.readlink().resolve() == dst


def symlink_file(config, lnk, dst):
    # TODO: Maybe install + validate in the same run?
    if config.dry_run:
        if symlink_is_ok(lnk, dst):
            if config.verbose:
                print("  Already ok: {} -> {}".format(lnk, dst))
        else:
            print("  Would install: {} -> {}".format(lnk, dst))
    else:
        if symlink_is_ok(lnk, dst):
            if config.verbose:
                print("  Already ok: {} -> {}".format(lnk, dst))
        else:
            if lnk.is_symlink():
                resolved = lnk.readlink().resolve()
                print("  Changing {} from {} to {}".format(lnk, resolved, dst))
                lnk.unlink()
            else:
                print("  Creating symlink: {} -> {}".format(lnk, dst))
                lnk.parent.mkdir(parents=True, exist_ok=True)
            symlink(dst, lnk)


def install(d, config):
    for f in os.listdir(d):
        if f in non_installable:
            continue
        abs_f = (Path(d) / f).resolve()
        HOME_f = HOME / f
        symlink_file(config, HOME_f, abs_f)

    for dst, special in exceptions.items():
        if sys.platform not in special.platforms:
            if config.verbose:
                print(
                    "Non-installable file: {} (sys.platform: {}, platforms: {})".format(
                        dst, sys.platform, special.platforms
                    )
                )
            continue

        lnk = special.path.expanduser()
        dst = Path(dst)
        if not dst.is_absolute():
            dst = Path.cwd() / dst
        dst.resolve()

        symlink_file(config, lnk, dst)


command_functions = {
    "install": install,
    "validate": validate,
}


def function_for_command(command, parser):
    if command not in command_functions:
        print("The only available commands are install and validate")
        return lambda *args: parser.print_usage()
    return command_functions[command]


def main():
    dot_files_dir = os.path.dirname(os.path.realpath(__file__))

    parser = argparse.ArgumentParser()
    parser.add_argument("--verbose", "-v", action="store_true")
    parser.add_argument("--dry_run", "-n", action="store_true")
    parser.add_argument("command", nargs="?", default="validate")
    args = parser.parse_args()

    function_for_command(args.command, parser)(dot_files_dir, args)


if __name__ == "__main__":
    main()
