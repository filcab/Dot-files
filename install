#!/usr/bin/env python
import argparse
import os
import sys

from pathlib import Path

DEFAULT_COMMAND = "validate"
# TODO: Do we want to possibly install elsewhere?
HOME = Path.home()
non_installable = [".git", ".gitignore", "install"]

exceptions = {
    "Microsoft.PowerShell_profile.ps1": (
        Path.home() / "Documents/PowerShell/Microsoft.PowerShell_profile.ps1"
    ),
}
non_installable += exceptions.keys()


def info(*args, **kwargs):
    print("[*]", *args, **kwargs)


def error(*args, **kwargs):
    print("[E]", *args, **kwargs)


if sys.platform == "win32":
    __CSL = None

    def symlink(source, link_name):
        """symlink(source, link_name)
        Creates a symbolic link pointing to source named link_name"""
        global __CSL
        if __CSL is None:
            import ctypes

            csl = ctypes.windll.kernel32.CreateSymbolicLinkW
            csl.argtypes = (ctypes.c_wchar_p, ctypes.c_wchar_p, ctypes.c_uint32)
            csl.restype = ctypes.c_ubyte
            __CSL = csl
        flags = 0
        if source is not None and os.path.isdir(source):
            flags = 1
        if __CSL(str(link_name), str(source), flags) == 0:
            raise ctypes.WinError()


else:

    def symlink(source, link_name):
        return os.symlink(source, link_name)


def validate_link(lnk, dst, config):
    if not lnk.exists():
        error("symlink to {} is not installed at {}".format(dst, lnk))
        had_error = True
        return
    if not lnk.is_symlink():
        error("{} exists but is not a symlink".format(lnk))
        had_error = True
        return
    link = lnk.readlink().resolve()
    if link != dst:
        error(
            "{} exists but is not a symlink to {}, it points to {}".format(
                lnk, dst, link
            )
        )
        had_error = True
        return
    if config.verbose:
        info("OK: {} -> {}".format(lnk, dst))


def validate(d, config):
    had_error = False
    for f in os.listdir(d):
        if f in non_installable:
            if config.verbose and f not in exceptions:
                print("Non-installable file: {}".format(f))
            continue

        abs_f = (Path(d) / f).resolve()
        HOME_f = Path(HOME) / f
        validate_link(HOME_f, abs_f, config)

    for dst, lnk in exceptions.items():
        lnk = lnk.expanduser()
        dst = Path(dst)
        if not dst.is_absolute():
            dst = Path.cwd() / dst
        dst.resolve()

        validate_link(lnk, dst, config)

    info("All seems to be ok!")


def symlink_is_ok(lnk, dst):
    return lnk.exists() and lnk.is_symlink() and lnk.readlink().resolve() == dst


def install(d, config):
    def symlink_file(lnk, dst):
        # TODO: Maybe install + validate in the same run?
        if config.dry_run:
            if symlink_is_ok(lnk, dst):
                if config.verbose:
                    print("  Already ok: {} -> {}".format(lnk, dst))
            else:
                print("  Would install: {} -> {}".format(lnk, dst))
        else:
            if symlink_is_ok(lnk, dst):
                if config.verbose:
                    print("  Already ok: {} -> {}".format(lnk, dst))
            else:
                if lnk.is_symlink():
                    resolved = lnk.readlink().resolve()
                    print("  Changing {} from {} to {}".format(lnk, resolved, dst))
                    lnk.unlink()
                else:
                    print("  Creating symlink: {} -> {}".format(lnk, dst))
                    lnk.parent.mkdir(parents=True, exist_ok=True)
                symlink(dst, lnk)

    had_error = False
    for f in os.listdir(d):
        if f in non_installable:
            continue
        abs_f = (Path(d) / f).resolve()
        HOME_f = HOME / f
        symlink_file(HOME_f, abs_f)

    for dst, lnk in exceptions.items():
        lnk = lnk.expanduser()
        dst = Path(dst)
        if not dst.is_absolute():
            dst = Path.cwd() / dst
        dst.resolve()

        symlink_file(lnk, dst)


command_functions = {
    "install": install,
    "validate": validate,
}


def function_for_command(command, parser):
    if command not in command_functions:
        print('The only available command is "validate"')
        return lambda *args: parser.print_usage()
    return command_functions[command]


def main():
    dot_files_dir = os.path.dirname(os.path.realpath(__file__))

    parser = argparse.ArgumentParser()
    parser.add_argument("--verbose", "-v", action="store_true")
    parser.add_argument("--dry_run", "-n", action="store_true")
    parser.add_argument("command", nargs="?", default="validate")
    args = parser.parse_args()

    function_for_command(args.command, parser)(dot_files_dir, args)


if __name__ == "__main__":
    main()
