""" Start of FilCab's stuff
" Setup up pathogen and only turn on filetype stuff afterwards
filetype off

call pathogen#infect()
call pathogen#helptags()

" reset to vim-defaults
if &compatible          " only if not set before:
  set nocompatible      " use vim-defaults instead of vi-defaults (easier, more user friendly)
endif

""""""""""""""""""""""""""""""""""""""""""
" From tpope's sensible.vim (last checked on 2017-11-15):
" https://github.com/tpope/vim-sensible/blob/master/plugin/sensible.vim
" Changes are commented
if has('autocmd' )
  filetype plugin indent on
endif
if has('syntax') && !exists('g:syntax_on')
  syntax enable
endif

set autoindent
set backspace=indent,eol,start
"set complete-=i  " filcab: Trying it out with this set, for now
set complete+=d  "filcab: Trying it out with this additional one
set smarttab

"set nrformats-=octal  "filcab: haven't yet had problems with this

" filcab: Set some default. I don't care much
if !has('nvim') && &ttimeoutlen == -1
  set ttimeout
  set ttimeoutlen=100
endif

set incsearch
" Use <C-L> to clear the highlighting of :set hlsearch.
if maparg('<C-L>', 'n') ==# ''
  nnoremap <silent> <C-L> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>
endif

" Always show the status bar
set laststatus=2
set ruler               " show cursor position in status bar
set wildmenu

if !&scrolloff
  set scrolloff=2         " 2 lines above/below cursor when scrolling
endif
if !&sidescrolloff
  set sidescrolloff=5
endif
set display+=lastline

scriptencoding utf-8  " filcab: In sensible, this is conditional
set encoding=utf-8    " filcab: Not in sensible

if &listchars ==# 'eol:$'
  "filcab: sensible.vim version:
  " set listchars=tab:>\ ,trail:-,extends:>,precedes:<,nbsp:+
  "
  " From silvas' vimrc:
  " Use Knuth-y underspace for trailing space
  " I once had a problem with › where it would show up wrong. Use ` instead
  " (I've actually come to prefer it, since it is smaller).
  set listchars=tab:`\ ,trail:␣"⎕",eol:◺
endif

if v:version > 703 || v:version == 703 && has("patch541")
  set formatoptions+=j " Delete comment character when joining commented lines
endif

" huh?
if has('path_extra')
  setglobal tags-=./tags tags-=./tags; tags^=./tags;
endif

if &shell =~# 'fish$' && (v:version < 704 || v:version == 704 && !has('patch276'))
  set shell=/bin/bash
endif

" Automatically reload changed files
set autoread

if &history < 1000
  set history=1000
endif
if &tabpagemax < 50
  set tabpagemax=50
endif
if !empty(&viminfo)
  set viminfo^=!
endif
set sessionoptions-=options

" Load matchit.vim, but only if the user hasn't installed a newer version.
if !exists('g:loaded_matchit') && findfile('plugin/matchit.vim', &rtp) ==# ''
  runtime! macros/matchit.vim
endif

" When doing "delete to beginning of line" in insert mode, "break" undo first
" so we can easily recover from mistakes.
inoremap <C-U> <C-G>u<C-U>

" End of tpope's sensible.vim stuff
""""""""""""""""""""""""""""""""""""""""""


" Tell vim where to find ack
let g:ackprg="~/dev/homebrew/bin/ack -H --nocolor --nogroup --column"

" Tell vim where to find clang-*
let g:filcab_exe_suffix = has('win32') ? '.exe' : ''
function! FindProgram(prog_name, dirs)
  if executable(a:prog_name) == 1
    return a:prog_name
  endif

  for dir in a:dirs
    let l:maybe_prog = expand(dir . '/' . a:prog_name . g:filcab_exe_suffix)
    if executable(l:maybe_prog) == 1
      return l:maybe_prog
    endif
  endfor

  return a:prog_name . '.NOTFOUND'
endfunction

let g:filcab_llvm_dirs_to_search = ['~/dev/llvm/build/bin', '~/work/llvm-cmake/bin', 'c:/code/llvm/build-ninja/bin',  'c:/code/llvm/build-vs/bin']
let g:clang_check_path = FindProgram('clang-check', g:filcab_llvm_dirs_to_search)
let g:clang_format_path = FindProgram('clang-format', g:filcab_llvm_dirs_to_search)

" Always use proper slashes on Windows if our shell looks like a *NIX one.
if has('win32') && &shell =~? '.*sh.exe'
  set shellslash
endif

"Auto-reload vimrc
autocmd! bufwritepost vimrc source ~/.vim/vimrc


" Allow some commands with the first letter(s) capitalized
if has("user_commands")
    command! -bang -nargs=? -complete=file E e<bang> <args>
    command! -bang -nargs=? -complete=file W w<bang> <args>
    command! -bang -nargs=? -complete=file Wq wq<bang> <args>
    command! -bang -nargs=? -complete=file WQ wq<bang> <args>
    command! -bang Wa wa<bang>
    command! -bang WA wa<bang>
    command! -bang Q q<bang>
    command! -bang QA qa<bang>
    command! -bang Qa qa<bang>
endif

" Per FreeBSD's security advice
set nomodeline

" completion (CTRL+N) options
if !exists( "g:loaded_youcompleteme" )
  " If we set this variable and then reload vimrc, when YouCompleteMe is
  " enabled, we end up with some weird behaviour where words which YCM tries
  " to complete will get deleted whilst being written.
  set completeopt+=longest
endif

" vim is the default editor for vim's subshells
let $EDITOR = "vim"

" make grep always print the filename (default: without the -H)
set grepprg=grep\ -nH\ $*\ /dev/null

" Make %% in the command line expand to the directory of the current file
cabbr <expr> %% expand('%:p:h:gs?\\?/?')

" Make filename completion case-insensitive
if exists("&wildignorecase")
    set wildignorecase
endif

" LaTeX stuff
" enable spelling in LaTeX files
au BufRead,BufNewFile *.tex,*.bib  setlocal spell spelllang=en_us iskeyword+=: " So fig:figure gets completion support


let g:tex_flavor = 'latex'    " LaTeX is the default flavor (not plain TeX)
let g:tex_mapleader = ','     " Leader character for LaTeX plugin
let g:Tex_DefaultTargetFormat = 'pdf'
let g:Tex_MultipleCompileFormats = 'pdf'

let g:Tex_CompileRule_dvi = 'latex --interaction=nonstopmode $*'
let g:Tex_CompileRule_ps = 'dvips -Pwww -o $*.ps $*.dvi'
let g:Tex_CompileRule_pspdf = 'ps2pdf $*.ps'
let g:Tex_CompileRule_dvipdf = 'dvipdfm $*.dvi'
let g:Tex_CompileRule_pdf = 'xelatex -synctex=1 --interaction=nonstopmode $*'

let g:Tex_ViewRule_dvi = 'texniscope'
let g:Tex_ViewRule_ps = 'Preview'
let g:Tex_ViewRule_pdf = 'Skim'

let g:Tex_FormatDependency_ps  = 'dvi,ps'
let g:Tex_FormatDependency_pspdf = 'dvi,ps,pspdf'
let g:Tex_FormatDependency_dvipdf = 'dvi,dvipdf'

" Default statusline:
set statusline=%<%f%h%m%r%=%b\ 0x%B\ \ %l,%c%V\ %P

" When in a git repo, tell us the current branch
let &statusline = '%{fugitive#statusline()} ' . &statusline

" Add highlighting for function definition in C++
function! EnhanceCppSyntax()
  syn match cppFuncDef "::\~\?\zs\h\w*\ze([^)]*\()\s*\(const\)\?\)\?$"
  hi def link cppFuncDef Special
endfunction

" Make ninja the default makeprg and make clang the default compiler (for errorformat)
compiler clang
set makeprg=ninja

" From silvas' vimrc:
" Showing invisible characters {{{
set list

" Some nice default for *.h files in llvm
autocmd BufNewFile,BufRead **/*llvm*/**/*.h setlocal ft=cpp.doxygen
" clang uses these for defining node types, so it will be cpp for now
" (along with .def)
autocmd BufNewFile,BufRead *.inc,*.def setlocal ft=cpp
autocmd BufNewFile,BufRead *.modulemap setlocal tabstop=2 shiftwidth=2 softtabstop=2 expandtab

autocmd BufNewFile,BufRead *.ninja setlocal ft=ninja
autocmd Filetype ninja setlocal tabstop=2 shiftwidth=2 softtabstop=2 expandtab

" filcab: Add the lit.* files and set them to Python mode
autocmd BufNewFile,BufRead **/*llvm*/**/lit* setlocal ft=python

" Map <LocalLeader> to , by default (was \, same as <Leader>)
let maplocalleader=','

" Help for some bindings:
noremap <unique> <LocalLeader>? :map <LocalLeader><cr>
noremap <unique> <Leader>? :map <Leader><cr>

""" End of FilCab's stuff

" display settings
set background=dark     " enable for dark terminals
"set nowrap              " dont wrap lines
" FILCAB: Turn off textwidth in general. It's getting to be annoying.
"set textwidth=74
"set wrapmargin=4        " When wrapping, set up a margin
set nonumber            " do not show line numbers
set showmatch           " show matching bracket (briefly jump)
set showmode            " show mode in status bar (insert/replace/...)
set showcmd             " show typed command in status bar
set title               " show file in titlebar

if has("wildmenu")
  set wildignore+=*.a,*.o
  set wildignore+=*.pyc
  set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.png
  set wildignore+=.DS_Store,.git,.hg,.svn
  set wildignore+=*.framework
  set wildignore+=*~,*.swp,*.tmp
  set wildmenu            " completion with menu
  set wildmode=longest:full " complete longest match and show menu
endif

" editor settings
set esckeys             " map missed escape sequences (enables keypad keys)
set ignorecase          " case insensitive searching
set smartcase           " but become case sensitive if you type uppercase characters
set smartindent         " smart auto indenting
set magic               " change the way backslashes are used in search patterns
set bs=indent,eol,start " Allow backspacing over everything in insert mode
set backupdir=~/.vim/backup " Hide backups in the .vim directory

set tabstop=4           " number of spaces a tab counts for
set shiftwidth=2        " spaces for autoindents
set expandtab           " turn a tabs into spaces

" splitting settings
set splitbelow          " When splitting open the new file below or to the right
set splitright

" misc settings
set nospell             " Don't spell-check
"set fileformat=unix     " file mode is unix
set fileformats=unix,dos    " only detect unix file format, displays that ^M with dos files

set viminfo+='20,<500   " remember copy registers after quitting in the .viminfo file -- 20 jump links, regs up to 500 lines'
set hidden              " remember undo after quitting

set mouse=v             " use mouse in visual mode (not normal,insert,command,help mode

let g:yankring_history_file = '.vim.yankring_history'


" color settings (if terminal/gui supports it)
if &t_Co > 2 || has("gui_running")
  set hlsearch            " highlight search (very useful!)
  set guioptions-=T       " Don't show toolbar
  if has("gui_running")   " Only in a GUI
    "colorscheme ir_black  " A nice colorscheme I found online
    set background=dark
    colorscheme molokai
  endif

  if has('macunix')
    set guifont=Monaco:h14
  endif

  if has('win32')
    " Good, default Windows font (after Win7)
    set guifont=Consolas:h13
    " Make the window larger by default. This should fit 3 side-by-side panes
    " very easily.
    set lines=80 columns=280
  endif
endif

" Format changed lines on save
let g:filcab_no_clang_format_on_save = 0
function! ClangFormatOnSave()
  if !g:filcab_no_clang_format_on_save
    let l:formatdiff = 1
    pyf ~/.vim/clang-format.py
  endif
endfunction
autocmd BufWritePre *.h,*.c,*.cc,*.cpp call ClangFormatOnSave()

" clang-check functions and keybinding
function! ClangCheckImpl(cmd)
  if &autowrite | wall | endif
  echo "Running " . a:cmd . " ..."
  let l:output = system(a:cmd)
  cexpr l:output
  cwindow
  let w:quickfix_title = a:cmd
  if v:shell_error != 0
    cc
  else
    redraw  " Force a redraw so we see the next message (hint from help :echo)
    echo 'clang-check found no problems'
  endif
  let g:clang_check_last_cmd = a:cmd
endfunction
function! ClangCheck()
  let l:filename = expand('%')
  if l:filename =~ '\.\(cpp\|cxx\|cc\|c\)$'
    call ClangCheckImpl(g:clang_check_path . " " . l:filename)
  elseif exists("g:clang_check_last_cmd")
    call ClangCheckImpl(g:clang_check_last_cmd)
  else
    echo "Can't detect file's compilation arguments and no previous clang-check invocation!"
  endif
endfunction

autocmd Filetype c,cpp nnoremap <buffer><silent><unique> <F5> :call ClangCheck()<CR><CR>

"YouCompleteMe shortcuts
if !exists( "g:loaded_youcompleteme" )
  let g:ycm_add_preview_to_completeopt = 1
  " This should be independent of language, but let's start with C/C++ only
  " Later maybe have a function/macro/whatever to setup for the different file
  " types
  augroup cpp
    au Filetype c,cpp let maplocalleader=','
    " General (refresh)
    au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader><F5> :YcmForceCompileAndDiagnostics<cr>

    """""""" GoTo commands
    " Default (lowercase) is to use the imprecise (faster) function
    au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>g :YcmCompleter GoToImprecise<cr>
    au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>G :YcmCompleter GoTo<cr>

    " Default (lowercase) is to go to the definition, else declaration
    au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>d :YcmCompleter GoToDefinition<cr>
    au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>D :YcmCompleter GoToDeclaration<cr>

    " Bind to both lower and uppercase
    " Not available in C/C++: (available in Python and JS, though)
    "au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>r :YcmCompleter GoToReferences<cr>
    "au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>R :YcmCompleter GoToReferences<cr>

    " unsure this is needed:
    "au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>/ :YcmCompleter GoToDefinitionElseDeclaration<cr>

    """" C/C++ mode only, I guess
    " Bind to both lower and uppercase
    " FILCAB: Maybe override gf *if* we're sure there's a compilation database?
    " FILCAB: check https://github.com/martong/vim-compiledb-path
    au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>i :YcmCompleter GoToInclude<cr>
    au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>I :YcmCompleter GoToInclude<cr>

    """""""" Get commands (information)
    " Default (lowercase) is to use the imprecise (faster) function
    au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>t :YcmCompleter GetTypeImprecise<cr>
    au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>T :YcmCompleter GetType<cr>

    " Bind to both lower and uppercase
    au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>p :YcmCompleter GetParent<cr>
    au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>P :YcmCompleter GetParent<cr>

    " Bind to both lower and uppercase
    " 'd' is taken for definition/declaration
    au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>o :YcmCompleter GetDocImprecise<cr>
    au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>O :YcmCompleter GetDoc<cr>

    """""""" Refactoring
    au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>f :YcmCompleter FixIt<cr>

    """""""" Miscellaneous
    function! ShowYCMNumberOfWarningsAndErrors()
      echo 'YCM reports: Errors: ' . youcompleteme#GetErrorCount() . ' Warnings: ' . youcompleteme#GetWarningCount()
    endfunction
    au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>w :call ShowYCMNumberOfWarningsAndErrors()<cr>
    au Filetype c,cpp nnoremap <buffer><unique> <LocalLeader>W :call ShowYCMNumberOfWarningsAndErrors()<cr>
  augroup END
endif

" file type specific settings
if has("autocmd")
  " For debugging
  "set verbose=9

  " change to directory of current file automatically
  "autocmd BufEnter * lcd %:p:h

  " Put these in an autocmd group, so that we can delete them easily.
  augroup mostfiles
    au BufReadPre,BufNewFile
    \ *.xsl,*.xml,*.css,*.html,*.js,*.php,*.sql,*.sh,*.conf,*.cc,*.cpp,*.h
    \  setlocal shiftwidth=2 softtabstop=2 expandtab
    "\  setlocal smartindent shiftwidth=2 softtabstop=2 expandtab
  augroup END

  augroup tex
    au BufReadPre,BufNewFile
    \ *.tex
    \ set wrap setlocal shiftwidth=2 softtabstop=2 expandtab
  augroup END

  augroup perl
    " reset (disable previous 'augroup perl' settings)
    au!

    au BufReadPre,BufNewFile
    \ *.pl,*.pm
    \ setlocal formatoptions=croq smartindent shiftwidth=2 softtabstop=2 cindent cinkeys='0{,0},!^F,o,O,e' " tags=./tags,tags,~/devel/tags,~/devel/C
    " formatoption:
    "   t - wrap text using textwidth
    "   c - wrap comments using textwidth (and auto insert comment leader)
    "   r - auto insert comment leader when pressing <return> in insert mode
    "   o - auto insert comment leader when pressing 'o' or 'O'.
    "   q - allow formatting of comments with "gq"
    "   a - auto formatting for paragraphs
    "   n - auto wrap numbered lists
    "
  augroup END

  augroup python
    au BufReadPre,BufNewFile *.py setlocal shiftwidth=4
  augroup END

  augroup filetype
    " LLVM stuff
    " sO:" -,mO:"  ,eO:"",:"
    "au! BufRead,BufNewFile *.ll     set filetype=llvm iskeyword+=% comments=s0:\ -,m0:;,e0:;;,:;
    au! BufRead,BufNewFile *.ll     set filetype=llvm iskeyword+=@ iskeyword+=%
    au! BufRead,BufNewFile *.td     set filetype=tablegen
    " SWIG
    au! BufRead,BufNewFile *.swig   set filetype=swig
  augroup END

  " Add highlighting for function definition in C++
  autocmd Syntax cpp call EnhanceCppSyntax()

  " clang-format integration
  autocmd Filetype c,cpp nnoremap <buffer><unique> <LocalLeader><Tab> :pyf ~/.vim/clang-format.py<cr>
  autocmd Filetype c,cpp vnoremap <buffer><unique> <LocalLeader><Tab> :pyf ~/.vim/clang-format.py<cr>
  autocmd Filetype c,cpp inoremap <buffer><unique> <C-S-Tab> <C-o>:pyf ~/.vim/clang-format.py<cr><cr>

  " Always jump to the last known cursor position.
  " Don't do it when the position is invalid or when inside
  " an event handler (happens when dropping a file on gvim).
  autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif

endif " has("autocmd")


" From http://vim.wikia.com/wiki/Auto_highlight_current_word_when_idle
" Highlight all instances of word under cursor, when idle.
" Useful when studying strange source code.
" Type z/ to toggle highlighting on/off.
nnoremap <unique> z/ :if AutoHighlightToggle()<Bar>set hls<Bar>endif<CR>
function! AutoHighlightToggle()
  let @/ = ''
  if exists('#auto_highlight')
    au! auto_highlight
    augroup! auto_highlight
    setl updatetime=4000
    echo 'Highlight current word: off'
    return 0
  else
    augroup auto_highlight
      au!
      au CursorHold * let @/ = '\V\<'.escape(expand('<cword>'), '\').'\>'
    augroup end
    setl updatetime=500
    echo 'Highlight current word: ON'
    return 1
  endif
endfunction

" silvas:
" experimental. note that \%# is used to match the cursor position, so that
" we aren't marking red the area that we are just typing.
match Error /\s\+\%#\@!$/

"nerdtree
" From: https://vimawesome.com/plugin/nerdtree-red
"       Close vim if the only window left open is a NERDTree
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

function! s:FC_CTRL_W_Help()
  echo 'Default CTRL-W key bindings. Also work as C-w C-<whatever>'
  echo 'command		   action in Normal mode'
  echo '----------------------------------------------------------'
  echo 'CTRL-W "	   terminal window: paste register'
  echo 'CTRL-W +	   increase current window height N lines'
  echo 'CTRL-W -	   decrease current window height N lines'
  echo 'CTRL-W .	   terminal window: type CTRL-W'
  echo 'CTRL-W :	   same as |:|, edit a command line'
  echo 'CTRL-W <	   decrease current window width N columns'
  echo 'CTRL-W =	   make all windows the same height & width'
  echo 'CTRL-W >	   increase current window width N columns'
  echo 'CTRL-W H	   move current window to the far left'
  echo 'CTRL-W J	   move current window to the very bottom'
  echo 'CTRL-W K	   move current window to the very top'
  echo 'CTRL-W L	   move current window to the far right'
  echo 'CTRL-W N	   terminal window: go to Terminal Normal mode'
  echo 'CTRL-W P	   go to preview window'
  echo 'CTRL-W R	   rotate windows upwards N times'
  echo 'CTRL-W S	   same as "CTRL-W s"'
  echo 'CTRL-W T	   move current window to a new tab page'
  echo 'CTRL-W W	   go to N previous window (wrap around)'
  echo 'CTRL-W ]	   split window and jump to tag under cursor'
  echo 'CTRL-W ^	   split current window and edit alternate file N'
  echo 'CTRL-W _	   set current window height to N (default: very high)'
  echo 'CTRL-W b	   go to bottom window'
  echo 'CTRL-W c	   close current window (like |:close|)'
  echo 'CTRL-W d	   split window and jump to definition under the cursor'
  echo 'CTRL-W f	   split window and edit file name under the cursor'
  echo 'CTRL-W F	   split window and edit file name under the cursor and jump to the line number following the file name.'
  echo 'CTRL-W g CTRL-]  split window and do |:tjump| to tag under cursor'
  echo 'CTRL-W g ]	   split window and do |:tselect| for tag under cursor'
  echo 'CTRL-W g }	   do a |:ptjump| to the tag under the cursor'
  echo 'CTRL-W g f	   edit file name under the cursor in a new tab page'
  echo 'CTRL-W g F	   edit file name under the cursor in a new tab page and jump to the line number following the file name.'
  echo 'CTRL-W h	   go to Nth left window (stop at first window)'
  echo 'CTRL-W i	   split window and jump to declaration of identifier under the cursor'
  echo 'CTRL-W j	   go N windows down (stop at last window)'
  echo 'CTRL-W k	   go N windows up (stop at first window)'
  echo 'CTRL-W l	   go to Nth right window (stop at last window)'
  echo 'CTRL-W n	   open new window, N lines high'
  echo 'CTRL-W o	   close all but current window (like |:only|)'
  echo 'CTRL-W p	   go to previous (last accessed) window'
  echo 'CTRL-W q	   quit current window (like |:quit|)'
  echo 'CTRL-W r	   rotate windows downwards N times'
  echo 'CTRL-W s	   split current window in two parts, new window N lines high'
  echo 'CTRL-W t	   go to top window'
  echo 'CTRL-W v	   split current window vertically, new window N columns wide'
  echo 'CTRL-W w	   go to N next window (wrap around)'
  echo 'CTRL-W x	   exchange current window with window N (default: next window)'
  echo 'CTRL-W z	   close preview window set window width to N columns'
  echo 'CTRL-W }	   show tag under cursor in preview window'
  echo ' '
  echo 'CTRL-W ?	   filcab: Show help'
endfunction
" Have some help menu for C-w
nnoremap <unique> <C-w>? :call <SID>FC_CTRL_W_Help()<cr>
inoremap <unique> <C-w>? <C-o>:call <SID>FC_CTRL_W_Help()<cr><cr>
