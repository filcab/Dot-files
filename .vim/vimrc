""""""""""""" Start of FilCab's stuff
" Setup up pathogen and only turn on filetype stuff afterwards
filetype off

call pathogen#infect()
call pathogen#helptags()

" reset to vim-defaults
if &compatible          " only if not set before:
  set nocompatible      " use vim-defaults instead of vi-defaults (easier, more user friendly)
endif

""""""""""""""""""""""""""""""""""""""""""
" From tpope's sensible.vim (last checked on 2017-11-15):
" https://github.com/tpope/vim-sensible/blob/master/plugin/sensible.vim
" Changes are commented
" filcab: had if has('autocmd'), which is true even in tiny builds
filetype plugin indent on
if has('syntax') && !exists('g:syntax_on')
  syntax enable
endif

set autoindent
set backspace=indent,eol,start
set complete+=d
set incsearch
set smarttab

"set nrformats-=octal  "filcab: haven't yet had problems with this

" filcab: Set some default. I don't care much
if !has('nvim') && &ttimeoutlen == -1
  set ttimeout
  set ttimeoutlen=100
endif

" Use <C-L> to clear the highlighting of :set hlsearch.
if maparg('<C-L>', 'n') ==# ''
  nnoremap <silent> <C-L> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>
endif

" Always show the status bar
set laststatus=2
set ruler               " show cursor position in status bar

if !&scrolloff
  set scrolloff=2         " 2 lines above/below cursor when scrolling
endif
if !&sidescrolloff
  set sidescrolloff=5
endif
set display+=lastline

scriptencoding utf-8  " filcab: In sensible, this is conditional
set encoding=utf-8    " filcab: Not in sensible

if &listchars ==# 'eol:$'
  "filcab: sensible.vim version:
  " set listchars=tab:>\ ,trail:-,extends:>,precedes:<,nbsp:+
  "
  " From silvas' vimrc:
  " Use Knuth-y underspace for trailing space
  " I once had a problem with › where it would show up wrong. Use ` instead
  " (I've actually come to prefer it, since it is smaller).
  set listchars=tab:`\ ,trail:␣"⎕",eol:◺
endif

set formatoptions+=j " Delete comment character when joining commented lines

" huh?
if has('path_extra')
  setglobal tags-=./tags tags-=./tags; tags^=./tags;
endif

" Automatically reload changed files
set autoread

if &history < 1000
  set history=1000
endif
if &tabpagemax < 50
  set tabpagemax=50
endif
if !empty(&viminfo)
  set viminfo^=!
endif
set sessionoptions-=options

" Load matchit.vim, but only if the user hasn't installed a newer version.
if !exists('g:loaded_matchit') && findfile('plugin/matchit.vim', &rtp) ==# ''
  runtime! macros/matchit.vim
endif

" When doing "delete to beginning of line" in insert mode, "break" undo first
" so we can easily recover from mistakes.
inoremap <C-U> <C-G>u<C-U>

" End of tpope's sensible.vim stuff
""""""""""""""""""""""""""""""""""""""""""

" LSP setup is not ready yet (needs to come before mappings)
let g:disable_youcompleteme = 0

source $HOME/.vim/utilities.vim

""""""""""""" Find programs used by plugins
let g:filcab_llvm_dirs_to_search = ['~/dev/llvm/build/bin', '~/work/llvm-cmake/bin', 'c:/code/llvm/install/bin', 'c:/code/llvm/build/bin', 'c:/code/llvm/build-ninja/bin',  'c:/code/llvm/build-vs/bin']
let g:clang_check_path = FindProgram('clang-check', g:filcab_llvm_dirs_to_search)
let g:clang_format_path = FindProgram('clang-format', g:filcab_llvm_dirs_to_search)

let g:filcab_cquery_dirs_to_search = ['~/dev/cquery/build']

" Tell vim where to find ack
let g:filcab_homebrew_dirs_to_search = ['~/dev/brew/bin', '~/dev/homebrew/bin']
let g:ackprg=FindProgram('ack', g:filcab_homebrew_dirs_to_search) . ' -H --nocolor --nogroup --column'

" make grep always print the filename (default: without the -H)
set grepprg=grep\ -nH\ $*\ /dev/null

" Make ninja the default makeprg and make clang the default compiler (for errorformat)
compiler! clang
set makeprg=ninja

" Always use proper slashes on Windows if our shell looks like a *NIX one.
if has('win32') && &shell =~? '.*sh.exe'
  set shellslash
endif

"Auto-reload vimrc
autocmd! BufWritePost vimrc source ~/.vim/vimrc


" Allow some commands with the first letter(s) capitalized
if has('user_commands')
    command! -bang -nargs=? -complete=file E e<bang> <args>
    command! -bang -nargs=? -complete=file W w<bang> <args>
    command! -bang -nargs=? -complete=file Wq wq<bang> <args>
    command! -bang -nargs=? -complete=file WQ wq<bang> <args>
    command! -bang Wa wa<bang>
    command! -bang WA wa<bang>
    command! -bang Q q<bang>
    command! -bang QA qa<bang>
    command! -bang Qa qa<bang>
endif

" Per FreeBSD's security advice
set nomodeline

" Set this wether or not we're disabling ycm, since we might not find the LSP
" programs
let g:ycm_global_ycm_extra_conf = '~/.vim/ycm_extra_conf.py'
if g:disable_youcompleteme
  " switching to clangd/lsp, so let's disable ycm for the ft we have an LSP for
  let g:ycm_filetype_blacklist = {}

  let g:lsp_signs_enabled = 1
  let g:lsp_diagnostics_echo_cursor = 1 " enable echo under cursor when in normal mode
  "let g:lsp_log_verbose = 0
  "let g:lsp_log_file = expand('~/vim-lsp.log')

  if executable('pyls')
    let g:ycm_filetype_blacklist['python'] = 1
    " pip install python-language-server
    autocmd User lsp_setup call lsp#register_server({
            \ 'name': 'pyls',
            \ 'cmd': {server_info->['pyls']},
            \ 'whitelist': ['python'],
            \ })
    autocmd FileType python setlocal omnifunc=lsp#complete
  endif

  let g:cquery_path = FindProgram('cquery', g:filcab_cquery_dirs_to_search)
  if executable(g:cquery_path)
    let g:ycm_filetype_blacklist['c'] = 1
    let g:ycm_filetype_blacklist['cpp'] = 1
    let g:ycm_filetype_blacklist['objc'] = 1
    let g:ycm_filetype_blacklist['objcpp'] = 1
    autocmd User lsp_setup call lsp#register_server({
            \ 'name': 'cquery',
            \ 'cmd': {server_info->[g:cquery_path]},
            \ 'whitelist': ['c', 'cpp', 'objc', 'objcpp'],
            \ })
    autocmd FileType c,objc,cpp,objcpp setlocal omnifunc=lsp#complete
  endif

  let g:clangd_path = FindProgram('clangd', g:filcab_llvm_dirs_to_search)
  if executable(g:clangd_path)
    let g:ycm_filetype_blacklist['c'] = 1
    let g:ycm_filetype_blacklist['cpp'] = 1
    let g:ycm_filetype_blacklist['objc'] = 1
    let g:ycm_filetype_blacklist['objcpp'] = 1
    autocmd User lsp_setup call lsp#register_server({
            \ 'name': 'clangd',
            \ 'cmd': {server_info->[g:clangd_path]},
            \ 'whitelist': ['c', 'cpp', 'objc', 'objcpp'],
            \ })
    autocmd FileType c,objc,cpp,objcpp setlocal omnifunc=lsp#complete
  endif
endif

" completion (CTRL+N) options
if !exists( "g:loaded_youcompleteme" )
  " filcab:
  " If we set this variable and then reload vimrc, when YouCompleteMe is
  " enabled, we end up with some weird behaviour where words which YCM tries
  " to complete will get deleted whilst being written.
  set completeopt+=longest
endif

" vim is the default editor for vim's subshells
let $EDITOR = "vim"

" Make %% in the command line expand to the directory of the current file
cabbr <expr> %% expand('%:p:h:gs?\\?/?')

""""""""""""" LaTeX stuff
" enable spelling in LaTeX files
au BufRead,BufNewFile *.tex,*.bib  setlocal spell spelllang=en_us iskeyword+=: " So fig:figure gets completion support

let g:tex_flavor = 'latex'    " LaTeX is the default flavor (not plain TeX)
let g:tex_mapleader = ','     " Leader character for LaTeX plugin
let g:Tex_DefaultTargetFormat = 'pdf'
let g:Tex_MultipleCompileFormats = 'pdf'

let g:Tex_CompileRule_dvi = 'latex --interaction=nonstopmode $*'
let g:Tex_CompileRule_ps = 'dvips -Pwww -o $*.ps $*.dvi'
let g:Tex_CompileRule_pspdf = 'ps2pdf $*.ps'
let g:Tex_CompileRule_dvipdf = 'dvipdfm $*.dvi'
let g:Tex_CompileRule_pdf = 'xelatex -synctex=1 --interaction=nonstopmode $*'

let g:Tex_ViewRule_dvi = 'texniscope'
let g:Tex_ViewRule_ps = 'Preview'
let g:Tex_ViewRule_pdf = 'Skim'

let g:Tex_FormatDependency_ps  = 'dvi,ps'
let g:Tex_FormatDependency_pspdf = 'dvi,ps,pspdf'
let g:Tex_FormatDependency_dvipdf = 'dvi,dvipdf'
""""""""""""" LaTeX stuff end

" Default statusline:
set statusline=%<%f%h%m%r%=%b\ 0x%B\ \ %l,%c%V\ %P

" When in a git repo, tell us the current branch
let &statusline = '%{fugitive#statusline()} ' . &statusline

" From silvas' vimrc:
" Showing invisible characters {{{
set list

" Some nice default for *.h files in llvm
autocmd BufNewFile,BufRead **/*llvm*/**/*.h setlocal ft=cpp.doxygen
" clang uses these for defining node types, so it will be cpp for now
" (along with .def)
autocmd BufNewFile,BufRead *.inc,*.def setlocal ft=cpp

""""""""""""" End of FilCab's stuff

" display settings
" FILCAB: Turn off textwidth in general. It's getting to be annoying.
"set textwidth=74
"set wrapmargin=4        " When wrapping, set up a margin
set nonumber            " do not show line numbers
set showmatch           " show matching bracket (briefly jump)
set showmode            " show mode in status bar (insert/replace/...)
set showcmd             " show typed command in status bar
set title               " show file in titlebar

if has('wildmenu')
  set wildignore+=*.a,*.o
  set wildignore+=*.pyc
  set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.png
  set wildignore+=.DS_Store,.git,.hg,.svn
  set wildignore+=*.framework
  set wildignore+=*~,*.swp,*.tmp
  set wildmenu            " completion with menu
  set wildmode=longest:full " complete longest match and show menu
  " Make filename completion case-insensitive
  set wildignorecase
endif

" editor settings
set esckeys             " map missed escape sequences (enables keypad keys)
set ignorecase          " case insensitive searching
set smartcase           " but become case sensitive if you type uppercase characters
set smartindent         " smart auto indenting
set magic               " change the way backslashes are used in search patterns
set backupdir=$HOME/.vim/backups     " Hide backups in the .vim directory
set directory=$HOME/.vim/swapfiles// " Hide swap files in the .vim directory
if has('win32')
  set directory+=$TMP   "Fallback for weird platforms
endif

set tabstop=4           " number of spaces a tab counts for
set shiftwidth=2        " spaces for autoindents
set expandtab           " turn a tabs into spaces

" splitting settings
set splitbelow          " When splitting open the new file below or to the right
set splitright

" misc settings
set nospell             " Don't spell-check
"set fileformat=unix     " file mode is unix
set fileformats=unix,dos    " only detect unix file format, displays that ^M with dos files

set viminfo+='20,<500   " remember copy registers after quitting in the .viminfo file -- 20 jump links, regs up to 500 lines'
set hidden              " remember undo after quitting

set mouse=v             " use mouse in visual mode (not normal,insert,command,help mode

let g:yankring_history_file = '.vim.yankring_history'


" color settings (if terminal/gui supports it)
if &t_Co > 2 || has('gui_running')
  set hlsearch             " highlight search (very useful!)
  set guioptions-=T        " Don't show toolbar
  set background=dark
  if has('gui_running')    " Only in a GUI
    "colorscheme ir_black  " A nice colorscheme I found online
    colorscheme molokai
  endif

  if has('macunix')
    set guifont=Monaco:h14
  endif

  if has('win32') && has('gui_running') && has('vim_starting')
    " Good, default Windows font (after Win7)
    set guifont=Consolas:h13
    " Make the window larger by default. This should fit 3 side-by-side panes
    " very easily.
    set lines=80 columns=280
  endif
endif


" file type specific settings
" For debugging
"set verbose=9

" Put these in an autocmd group, so that we can delete them easily.
augroup perl
  " reset (disable previous 'augroup perl' settings)
  au!

  au BufReadPre,BufNewFile
  \ *.pl,*.pm
  \ setlocal cindent cinkeys='0{,0},!^F,o,O,e'
  " formatoption:
  "   t - wrap text using textwidth
  "   c - wrap comments using textwidth (and auto insert comment leader)
  "   r - auto insert comment leader when pressing <return> in insert mode
  "   o - auto insert comment leader when pressing 'o' or 'O'.
  "   q - allow formatting of comments with "gq"
  "   a - auto formatting for paragraphs
  "   n - auto wrap numbered lists
  "
augroup END

augroup python
  au BufReadPre,BufNewFile *.py setlocal shiftwidth=4
augroup END

augroup filetype
  " LLVM stuff
  " sO:" -,mO:"  ,eO:"",:"
  "au! BufRead,BufNewFile *.ll     set filetype=llvm iskeyword+=% comments=s0:\ -,m0:;,e0:;;,:;
  au! BufRead,BufNewFile *.ll     set filetype=llvm iskeyword+=@ iskeyword+=%
  " SWIG
  au! BufRead,BufNewFile *.swig   set filetype=swig
  " Javascript proxy stuff. Use "default" names only
  au! BufRead,BufNewFile proxy.pac,wpad.dat set filetype=javascript
augroup END

" Add highlighting for function definition in C++
function! EnhanceCppSyntax()
  syntax match cppFuncDef "::\~\?\zs\h\w*\ze([^)]*\()\s*\(const\)\?\)\?$"
  hi def link cppFuncDef Special
endfunction
autocmd Syntax cpp call EnhanceCppSyntax()

" Always jump to the last known cursor position.
" Don't do it when the position is invalid or when inside
" an event handler (happens when dropping a file on gvim).
autocmd BufReadPost *
  \ if line("'\"") > 0 && line("'\"") <= line("$") |
  \   exe "normal g`\"" |
  \ endif


" silvas:
" experimental. note that \%# is used to match the cursor position, so that
" we aren't marking red the area that we are just typing.
match Error /\s\+\%#\@!$/

"nerdtree
" From: https://vimawesome.com/plugin/nerdtree-red
"       Close vim if the only window left open is a NERDTree
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
