#!/usr/bin/env python3

from __future__ import print_function
import datetime
import os
import re
import sys
import subprocess
import timeit


# This can be useful when initially downloading a repo with some huge revisions which might timeout more than once
RETRIES = 1
# Number of retries for each batch
BATCH_RETRIES = 3
# Number of revisions to get per git svn fetch call
BATCH_REVS = 1000
# Hide the git() commands' output by default
QUIET = False
# Don't show vcs commands being executed
VERBOSE = False
# Update the refs after the fetch (if no error occurred)
UPDATE_REFS = False
START_REV = None


def check_for_and_remove(thing, l):
    if thing in l:
        l.remove(thing)
        return True
    return False


# Poor person's command line handling
if check_for_and_remove("-v", sys.argv) or check_for_and_remove("--verbose", sys.argv):
    VERBOSE = True
if check_for_and_remove("-u", sys.argv) or check_for_and_remove(
    "--update-refs", sys.argv
):
    UPDATE_REFS = True
if check_for_and_remove("-q", sys.argv) or check_for_and_remove("--quiet", sys.argv):
    QUIET = True
if len(sys.argv) >= 2:
    START_REV = sys.argv.pop()
assert len(sys.argv) == 1


def check_call_and_hide_lines(cmd, hide_re):
    CLEAR_TO_END_OF_LINE = "\033[2K"
    regexp = re.compile(hide_re)

    def xform(line):
        if regexp.match(line):
            return "{}{}{}\r".format(
                CLEAR_TO_END_OF_LINE,
                datetime.datetime.now().isoformat(" ")[:16],
                line.rstrip("\r\n"),
            )
        else:
            return "{}{}".format(CLEAR_TO_END_OF_LINE, line)

    p = subprocess.Popen(
        cmd, encoding="utf-8", stdout=subprocess.PIPE, stderr=subprocess.STDOUT
    )
    for line in p.stdout:
        print(xform(line), end="")
    ret = p.wait()
    if ret:
        raise subprocess.CalledProcessError(cmd=cmd, returncode=ret)
    return ret


# Problem: This mixes up stdout and stderr. I don't think we have a problem with that for any of our check_output calls
def check_output_and_hide_lines(cmd, hide_re):
    regexp = re.compile(hide_re)

    def xform(line):
        if regexp.match(line):
            return ""
        else:
            return line

    acc = ""
    p = subprocess.Popen(
        cmd, encoding="utf-8", stdout=subprocess.PIPE, stderr=subprocess.STDOUT
    )
    for line in p.stdout:
        line = xform(line)
        acc += line
    ret = p.wait()
    if ret:
        raise subprocess.CalledProcessError(cmd=cmd, returncode=ret, output=acc)
    return acc


# Utilities for easily calling the vcs programs
hide_re_for_stdout_err = r"^(W: .empty_dir|\s+[MAD]).*"


def git(*args, **kwargs):
    if VERBOSE:
        print("git({})".format(", ".join(args)))
    cmd = ["git"] + list(args)
    check_call_and_hide_lines(cmd, hide_re_for_stdout_err)


def git_output(*args, **kwargs):
    if VERBOSE:
        print("git_output({})".format(", ".join(args)))
    # Always rstrip() to remove the last newline. Change if needed
    cmd = ["git"] + list(args)
    return check_output_and_hide_lines(cmd, hide_re_for_stdout_err).rstrip()


def git_svn(*args, **kwargs):
    git("svn", *args)


def git_svn_output(*args, **kwargs):
    return git_output("svn", *args)


def svn(*args, **kwargs):
    # FIXME: Use what git uses
    (stdout, stderr) = (sys.stdout, sys.stderr)
    if VERBOSE:
        print("svn({})".format(", ".join(args)))
    subprocess.check_call(
        ["svn"] + list(args), encoding="utf-8", stdout=stdout, stderr=stderr
    )


def svn_output(*args, **kwargs):
    if VERBOSE:
        print("svn_output({})".format(", ".join(args)))
    # Always rstrip() to remove the last newline. Change if needed
    cmd = ["svn"] + list(args)
    return check_output_and_hide_lines(cmd, hide_re_for_stdout_err).rstrip()


def svn_revision_for(name):
    return git_svn_output("find-rev", name)


svn_repo = git_output("config", "svn-remote.svn.url")
print("[*] SVN repo: {}".format(svn_repo))
branch_name = git_output("rev-parse", "--abbrev-ref", "HEAD")
print("[*] Current git branch: {}".format(branch_name))
assert " " not in branch_name


# Returns True if no work has been done
def fetch_revisions():
    def git_svn_fetch_revs(start, end):
        retries = 0
        quiet = QUIET
        while retries < BATCH_RETRIES:
            try:
                svn_cmd = ["fetch"]
                if QUIET:
                    svn_cmd.append("-q")
                svn_cmd.append("-r{}:{}".format(start, end))
                git_svn(*svn_cmd)
                break
            except:
                retries += 1
                if retries == BATCH_RETRIES:
                    # t, v, tb = sys.exc_info()
                    # Re-raise the exception
                    raise
            if retries == 1 and quiet:
                print(
                    "[W] Hit an exception fetching. Turning off quiet mode for this batch!"
                )
                quiet = False

    if not START_REV:
        head_rev = int(svn_revision_for("HEAD"))
    else:
        assert START_REV.startswith("r")
        head_rev = int(START_REV[1:])

    svn_top_rev = int(svn_output("info", "--show-item", "revision", svn_repo))
    if head_rev == svn_top_rev:
        print("[*] We already have everything. Nothing to do.")
        return True

    print(
        "[*] Filling in revisions from git-HEAD (r{}) to svn-HEAD (r{})".format(
            head_rev, svn_top_rev
        )
    )

    start = head_rev
    end = svn_top_rev
    while start != "HEAD" and start < end:
        if start + BATCH_REVS >= end:
            batch_end = "HEAD"
        else:
            batch_end = min(start + BATCH_REVS, end)
        print("[*] Fetching a batch: r{}:{}".format(start, batch_end))
        time_start = timeit.default_timer()
        git_svn_fetch_revs(start, batch_end)
        elapsed = timeit.default_timer() - time_start
        print("[*] Time elapsed: {}s".format(elapsed))
        start = batch_end


last_one_failed = True
for retry in range(0, RETRIES):
    try:
        if fetch_revisions():
            # no-op, just exit
            sys.exit(0)
        # If we got here without a failure, we have everything.
        last_one_failed = False
        break
    except subprocess.CalledProcessError as e:
        print("[+] output: {}".format(e.output))
        if e.output:
            lines = e.output.splitlines()
            print("[+] last lines:")
            print(lines[-2])
            print(lines[-1])
            # Maybe run `git fsck` here


if last_one_failed:
    # Failure when fetching revisions. Bailing out!
    sys.exit(1)

is_bare = git_output("config", "core.bare")
if is_bare:
    # On a bare repo, update the master ref to trunk (other refs haven't been created. We'll eventually want a loop over tracked branches)
    update_cmd = [
        "update-ref",
        "-m",
        "git-svn-update",
        "refs/heads/{}".format(branch_name),
        "origin/trunk",
    ]
else:
    update_cmd = ["svn", "rebase", "-l"]


if UPDATE_REFS:
    if not os.path.isdir("refs/remotes"):
        print(
            "[W] Not updating, as I don't know what to do and I think I don't need to update"
        )
        sys.exit(0)
    if not START_REV:
        head_rev = int(svn_revision_for("HEAD"))
    else:
        assert START_REV.startswith("r")
        head_rev = int(START_REV[1:])

    git(*update_cmd)
    new_head_rev = int(svn_revision_for("HEAD"))
    additional_msg = ""
    if head_rev == new_head_rev:
        print(
            "Not updated, still at r{} (There are no new revisions which touch the files in this tree)".format(
                head_rev
            )
        )
    else:
        print("Updated from r{} to r{}".format(head_rev, new_head_rev))
    print("[*] All done. Hopefully it's ok.")
else:
    if not os.path.isdir("refs/remotes"):
        print("[*] All done! No refs/remotes so I think that's it.")
        sys.exit(0)
    update_cmd_str = "git {}".format(" ".join(update_cmd))
    print(
        "[*] All done. Hopefully it's ok. Please remember to run `{}` (hopefully that's right) to make sure you're up to date".format(
            update_cmd_str
        )
    )
    sys.exit(0)
