#!/usr/bin/env python

from __future__ import print_function
import os
import re
import sys
import subprocess

try:
    from subprocess import DEVNULL
except ImportError:
    import os
    # Just keep it open throughout
    DEVNULL = open(os.devnull, 'wb')


RETRIES = 100
# Number of revisions to get per git svn fetch call
BATCH_REVS = 1000
# Hide the git() commands' output by default
QUIET = False
# Don't show vcs commands being executed
VERBOSE = False
# Update the refs after the fetch (if no error occurred)
UPDATE_REFS = False
START_REV = None


def check_for_and_remove(thing, l):
    if thing in l:
        l.remove(thing)
        return True
    return False


# Poor person's command line handling
if check_for_and_remove('-v', sys.argv) or check_for_and_remove('--verbose', sys.argv) :
    VERBOSE = True
if check_for_and_remove('-u', sys.argv) or check_for_and_remove('--update-refs', sys.argv) :
    UPDATE_REFS = True
if check_for_and_remove('-q', sys.argv) or check_for_and_remove('--quiet', sys.argv) :
    QUIET = True
if len(sys.argv) >= 2:
    START_REV = sys.argv.pop()
assert len(sys.argv) == 1


# This object wraps a file-like and implements a simple file-like object which will:
#  - Buffer full lines (only dumps to the nested file-like if we have reached the end of a line)
#  - Replace a newline with a \r if the line *matches* a regex (therefore only showing the last line)
# FIXME: I don't care about str() vs bytes() for now
class SingleLineOutputIfRegex(object):
    def __init__(self, f, regex, flags=0):
        self.file = f
        self.re = re.compile(regex, flags)
        self.buffer = ''

    # We don't use backing files
    def fileno(self):
        return self.file.fileno()

    def read(self, n):
        pass
    def readline(self, limit):
        pass
    def write(self, thing):
        CLEAR_TO_END_OF_LINE = '\033[2K'
        if self.re.match(thing):
            return self.file.write('{}{}\r'.format(CLEAR_TO_END_OF_LINE, thing.rstrip('\r\n')))
        else:
            return self.file.write(thing)


# Utilities for easily calling the vcs programs
def out_err_for_subprocess():
    if QUIET:
        return (DEVNULL, SingleLineOutputIfRegex(sys.stderr,  '^(W: -empty_dir)'))
    else:
        return (None, subprocess.STDOUT)
def git(*args, **kwargs):
    (stdout, stderr) = out_err_for_subprocess()
    if VERBOSE:
        print('git({})'.format(', '.join(args)))
    subprocess.check_call(['git'] + list(args), stdout=stdout, stderr=stderr)
def git_output(*args, **kwargs):
    if VERBOSE:
        print('git_output({})'.format(', '.join(args)))
    # Always rstrip() to remove the last newline. Change if needed
    return subprocess.check_output(['git'] + list(args), stderr=subprocess.STDOUT).rstrip()
def git_svn(*args, **kwargs):
    git('svn', *args)
def git_svn_output(*args, **kwargs):
    return git_output('svn', *args)
def svn(*args, **kwargs):
    (stdout, stderr) = out_err_for_subprocess()
    if VERBOSE:
        print('svn({})'.format(', '.join(args)))
    subprocess.check_call(['svn'] + list(args), stdout=stdout, stderr=stderr)
def svn_output(*args, **kwargs):
    if VERBOSE:
        print('svn_output({})'.format(', '.join(args)))
    # Always rstrip() to remove the last newline. Change if needed
    return subprocess.check_output(['svn'] + list(args), stderr=subprocess.STDOUT).rstrip()
def svn_revision_for(name):
    return git_svn_output('find-rev', name)


svn_repo = git_output('config', 'svn-remote.svn.url')
print('[*] SVN repo: {}'.format(svn_repo))
branch_name = git_output('rev-parse', '--abbrev-ref', 'HEAD')
print('[*] Current git branch: {}'.format(branch_name))


import timeit
# Returns True if no work has been done
def fetch_revisions():
    def git_svn_fetch_revs(start, end):
        git_svn('fetch', '-q', '-r{}:{}'.format(start, end))

    if not START_REV:
        head_rev = int(svn_revision_for('HEAD'))
    else:
        assert START_REV.startswith('r')
        head_rev = int(START_REV[1:])

    svn_top_rev = int(svn_output('info', '--show-item', 'revision', svn_repo))
    if head_rev == svn_top_rev:
        print('[*] We already have everything. Nothing to do.')
        return True

    print('[*] Filling in revisions from git-HEAD (r{}) to svn-HEAD (r{})'.format(head_rev, svn_top_rev))

    def fetch_revision_batches(start, end):
        time_start = timeit.default_timer()
        if start + BATCH_REVS >= end:
            end = 'HEAD'
            print('[*] Fetching a batch: r{}:{}'.format(start, end))
            git_svn_fetch_revs(start, end)
        else:
            batch_top = min(start + BATCH_REVS, end)
            print('[*] Fetching a batch: r{}:{}'.format(start, batch_top))
            git_svn_fetch_revs(start, batch_top)
            elapsed = timeit.default_timer() - time_start
            print('[*] Time elapsed: {}s'.format(elapsed))
            # Loop until finished
            fetch_revision_batches(start + BATCH_REVS, end)
    fetch_revision_batches(head_rev, svn_top_rev)


for retry in range(0, RETRIES):
    try:
        if fetch_revisions():
            # no-op, just exit
            sys.exit(0)
        # If we got here without a failure, we have everything.
        break
    except subprocess.CalledProcessError as e:
        print('[+] output: {}'.format(e.output))
        if e.output:
            lines = e.output.splitlines()
            print('[+] last lines:')
            print(lines[-2])
            print(lines[-1])
            # Maybe run `git fsck` here


is_bare = git_output('config', 'core.bare')
if is_bare:
    # On a bare repo, update the master ref to trunk (other refs haven't been created. We'll eventually want a loop over tracked branches)
    update_cmd = ['update-ref', '-m', 'git-svn-update', 'refs/heads/{}'.format(branch_name), 'origin/trunk']
else:
    update_cmd = ['svn', 'rebase', '-l']


if UPDATE_REFS:
    if not START_REV:
        head_rev = int(svn_revision_for('HEAD'))
    else:
        assert START_REV.startswith('r')
        head_rev = int(START_REV[1:])

    git(*update_cmd)
    new_head_rev = int(svn_revision_for('HEAD'))
    additional_msg = ''
    if head_rev == new_head_rev:
        additional_msg = ' (There are no new revisions which touch the files in this tree)'
    print('Updated from r{} to r{}{}'.format(head_rev, new_head_rev, additional_msg))
    print("[*] All done. Hopefully it's ok.")
else:
    update_cmd_str = 'git {}'.format(' '.join(update_cmd))
    print("[*] All done. Hopefully it's ok. Please remember to run `{}` (hopefully that's right) to make sure you're up to date".format(update_cmd_str))
    sys.exit(0)

